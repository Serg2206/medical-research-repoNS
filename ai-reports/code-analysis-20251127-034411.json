[
  {
    "file": "train.py",
    "timestamp": "2025-11-27T03:43:12.268489",
    "metrics": {
      "complexity": "train.py\n    F 77:0 train_model - A (4)\n    F 47:0 prepare_data - A (3)\n    C 22:0 MedicalDataset - A (2)\n    M 23:4 MedicalDataset.__init__ - A (1)\n    M 28:4 MedicalDataset.__len__ - A (1)\n    M 31:4 MedicalDataset.__getitem__ - A (1)\n",
      "maintainability": "train.py - A (69.54)\n"
    },
    "ai_recommendations": "В целом, код хорошо структурирован и легко читается. Однако, есть несколько мест, которые можно улучшить:\n\n1. **Обработка ошибок**: В функции `prepare_data` есть проверка на наличие необходимых столбцов в CSV-файле. Это хорошо, но можно добавить больше проверок на валидность данных, например, проверить, что столбец 'label' содержит только ожидаемые значения.\n\n2. **Читаемость**: В функции `__getitem__` класса `MedicalDataset` создается словарь `tokens`, а затем из него извлекаются значения. Это может быть немного запутанно для чтения. Лучше создать отдельные переменные для каждого значения, чтобы улучшить читаемость.\n\n3. **Производительность**: В функции `train_model` используется цикл для обучения модели. Это может быть неэффективно, особенно если датасет большой. Лучше использовать библиотеки, которые могут оптимизировать этот процесс, такие как PyTorch Lightning или Ignite.\n\n4. **Best Practices**: Вместо использования глобальных переменных `MODEL_NAME` и `DEVICE` лучше передавать их в качестве аргументов функциям, которые их используют. Это делает код более модульным и упрощает тестирование.\n\n5. **Зависимости**: В коде используются библиотеки pandas, torch и transformers. Хорошей практикой является указание версий этих библиотек, чтобы гарантировать, что код будет работать, как ожидается, в любой среде.\n\n6. **Документация**: Хотя некоторые функции имеют строку документации, не все из них полностью документированы. Хорошей практикой является документирование всех функций, включая описание их параметров и возвращаемых значений.\n\n7. **Сохранение модели**: В конце обучения модель сохраняется, но не сохраняется информация об обучении, такая как потери и метрики. Это может быть полезно для анализа процесса обучения и сравнения различных моделей.",
    "lines_of_code": 124
  },
  {
    "file": "main.py",
    "timestamp": "2025-11-27T03:43:28.630428",
    "metrics": {
      "complexity": "main.py\n    F 32:0 train_model - A (4)\n    F 72:0 predict - A (2)\n    C 14:0 MedicalNet - A (2)\n    F 92:0 main - A (1)\n    M 15:4 MedicalNet.__init__ - A (1)\n    M 22:4 MedicalNet.forward - A (1)\n",
      "maintainability": "main.py - A (74.92)\n"
    },
    "ai_recommendations": "В целом, код хорошо структурирован и легко читаем. Однако, есть несколько мест, которые можно улучшить:\n\n1. **Импорты**: Импорт модуля `os` не используется в коде, его можно удалить.\n\n2. **Архитектура модели**: В текущей архитектуре модели используется один и тот же размер скрытого слоя для всех слоев. Это может не всегда быть оптимальным решением, и в некоторых случаях может быть полезно использовать разные размеры скрытых слоев.\n\n3. **Обучение модели**: Во время обучения модели, вычисление общего потерь (`total_loss`) не нормализуется по количеству батчей. Это может привести к неправильной оценке потерь, особенно если размер батча или количество батчей изменяется. Лучше нормализовать `total_loss` по количеству батчей.\n\n4. **Сохранение модели**: Сохранение модели происходит после каждой эпохи, что может быть неэффективным, если количество эпох большое. Вместо этого, можно сохранять модель только после последней эпохи, или когда достигается наилучшая точность на валидационном наборе данных.\n\n5. **Предсказание**: В функции `predict` модель загружается каждый раз при вызове функции. Это может быть неэффективно, если функция вызывается много раз. Вместо этого, можно загрузить модель один раз и передавать ее в функцию в качестве аргумента.\n\n6. **Обработка ошибок**: В коде нет обработки ошибок. Например, при загрузке модели, если файл модели не найден, будет сгенерировано исключение. Лучше обрабатывать такие ошибки и выводить понятные сообщения об ошибках.\n\n7. **Кодирование классов**: В коде предполагается, что метки классов уже закодированы как 0 и 1. Если это не так, код может не работать корректно. Лучше добавить кодирование классов в код, или указать это требование в комментариях.\n\n8. **Комментарии и документация**: Хотя код в целом хорошо комментирован, некоторые функции и классы не имеют комментариев или документации. Лучше добавить комментарии и документацию для всех функций и классов, чтобы упростить понимание кода другими разработчиками.",
    "lines_of_code": 111
  },
  {
    "file": "infer.py",
    "timestamp": "2025-11-27T03:43:42.522167",
    "metrics": {
      "complexity": "infer.py\n    F 10:0 infer_model - A (2)\n",
      "maintainability": "infer.py - A (74.30)\n"
    },
    "ai_recommendations": "В целом, код хорошо структурирован и читаем, но есть несколько областей, где можно внести улучшения:\n\n1. **Производительность**: Модель и токенизатор загружаются каждый раз, когда вызывается функция `infer_model`. Если вы планируете вызывать эту функцию несколько раз, это может быть неэффективно. Вместо этого, вы можете загрузить модель и токенизатор один раз вне функции и затем передать их в функцию в качестве аргументов.\n\n2. **Читаемость**: Код может быть более читаемым, если добавить комментарии к каждому блоку кода, объясняющие, что он делает. Например, объяснить, что делает `model.eval()` и `with torch.no_grad():`.\n\n3. **Best Practices**: Вместо использования `print` для вывода результатов, рассмотрите возможность использования стандартного модуля `logging` Python. Это позволит вам более гибко управлять уровнем важности сообщений, которые вы хотите отображать, и куда вы хотите их отправлять.\n\n4. **Безопасность**: В этом коде нет явных проблем с безопасностью. Однако, если текст, который вы анализируете, приходит из ненадежного источника, убедитесь, что вы обрабатываете его соответствующим образом, чтобы избежать инъекций кода или других атак.\n\n5. **Обработка ошибок**: Ваш код не содержит обработки исключений. Важно добавить обработку ошибок для случаев, когда модель или токенизатор не могут быть загружены, или когда возникают проблемы с входным текстом.\n\n6. **Тестирование**: Ваш код не содержит тестов. Хорошей практикой является написание модульных и интеграционных тестов для проверки корректности работы вашего кода.",
    "lines_of_code": 35
  },
  {
    "file": "prepare_data.py",
    "timestamp": "2025-11-27T03:43:57.287561",
    "metrics": {
      "complexity": "prepare_data.py\n    F 13:0 prepare_data - A (3)\n",
      "maintainability": "prepare_data.py - A (84.99)\n"
    },
    "ai_recommendations": "В целом, код хорошо структурирован, легко читаем и следует некоторым из best practices. Однако есть несколько мест, которые можно улучшить:\n\n1. **Обработка исключений**: В коде отсутствует обработка исключений при чтении CSV-файла. Если файл не найден или поврежден, программа просто упадет. Лучше обернуть чтение файла в блок try/except и добавить соответствующее сообщение об ошибке.\n\n2. **Очистка данных**: В коде присутствует очистка данных, но она минимальна (удаление пробелов в начале и конце). В зависимости от данных, возможно, потребуется более тщательная очистка, например, удаление специальных символов, приведение текста к нижнему регистру и т.д.\n\n3. **Документация**: Хотя функция `prepare_data` имеет строку документации, она не описывает формат входного CSV-файла. Хорошей практикой является описание формата входных и выходных данных функции.\n\n4. **Тестирование**: В коде отсутствуют тесты. Хорошей практикой является написание модульных тестов для проверки корректности работы функций.\n\n5. **Константы**: В коде используется константа `42` в качестве `random_state` для функции `train_test_split`. Хотя это общепринятое значение, лучше вынести его в глобальную константу с говорящим именем, чтобы упростить изменение и улучшить читаемость кода.\n\n6. **Логирование**: Логирование используется, но сообщения могут быть не очень информативными. Например, вместо сообщения \"Обработанные данные сохранены в {output_dir}\", можно добавить информацию о том, сколько строк было сохранено в каждом файле.\n\n7. **Использование f-строк**: В коде используются f-строки для форматирования сообщений. Это современный и удобный способ форматирования, но он не поддерживается в версиях Python до 3.6. Если поддержка старых версий Python важна, стоит использовать другие методы форматирования.",
    "lines_of_code": 53
  },
  {
    "file": "scripts/fix_csv_headers.py",
    "timestamp": "2025-11-27T03:44:11.669154",
    "metrics": {
      "complexity": "",
      "maintainability": "scripts/fix_csv_headers.py - A (90.78)\n"
    },
    "ai_recommendations": "В целом, код написан хорошо, но есть несколько моментов, которые можно улучшить:\n\n1. **Производительность**: Вместо того, чтобы сначала считывать все строки из файла в список, а затем обрабатывать их, можно обрабатывать строки по одной прямо во время чтения. Это позволит снизить потребление памяти и увеличить скорость обработки для больших файлов.\n\n2. **Безопасность**: В данном случае, особенностей безопасности нет, так как нет работы с сетью, базами данных или пользовательским вводом.\n\n3. **Читаемость**: Код вполне читаем, но можно улучшить его структуру, разделив его на функции. Это упростит понимание кода и его поддержку в будущем.\n\n4. **Best practices**: Использование модуля `csv` для работы с CSV файлами обычно предпочтительнее, чем ручная обработка строк. Это упрощает код и делает его более надежным.\n\nВот пример улучшенного кода:\n\n```python\n#!/usr/bin/env python3\n\"\"\"Fix CSV file by removing invalid header rows\"\"\"\n\nimport csv\nimport sys\n\ndef clean_csv(input_file, output_file):\n    with open(input_file, \"r\", encoding=\"utf-8\") as f_in, open(output_file, \"w\", encoding=\"utf-8\") as f_out:\n        reader = csv.reader(f_in)\n        writer = csv.writer(f_out)\n\n        valid_lines = 0\n        invalid_lines = 0\n\n        for i, row in enumerate(reader):\n            if i == 0 or len(row) > 1:  # Keep the header row and valid rows\n                writer.writerow(row)\n                valid_lines += 1\n            else:\n                print(f\"Removing invalid line {i+1}: {','.join(row)}\")\n                invalid_lines += 1\n\n        print(f\"\\nDone! Kept {valid_lines} valid lines, removed {invalid_lines} invalid lines\")\n\nif __name__ == \"__main__\":\n    clean_csv(\"training-data/medical_training_data.csv\", \"training-data/cleaned_medical_training_data.csv\")\n```\n\nВ этом коде функция `clean_csv` открывает входной и выходной файлы одновременно, что позволяет обрабатывать строки по одной, не загружая все строки в память. Кроме того, использование модуля `csv` делает код более надежным и упрощает его.",
    "lines_of_code": 29
  }
]